1-a.
I use the parse.exe from HW1
./parse  -g  arith.gr < arith.sen
./parse  -g  arith.gr < arith.sen | ./prettyprint
./parse  -g  arith.gr < arith.sen | ./prettyprint > arith.par
./buildattrs  arith.gra  arith.par

1-b
./buildattrs  arith-infix.gra  arith.par

1-c
./parse  -g  arith.gr < arith-typed.sen >  arith-typed.par
./buildattrs  arith-typed.gra  arith-typed.par

2
(%x x*x)(3)
(%x x*x)(y+y)
(%x x*x)(y) + y
(%a a)(%b f(b))
(%a 3)(%b f(b))
(%x green(x))(y)
(%x %y ate(x,y))(lemur, leopard)
(%x %y ate(x,y))(lemur)
(%x %y ate(x,y))(lemur)(leopard)
(%x f(x,y))(a)(b)(c(z))
(%x f(x,y))(a,b,c(z))
(%f f(x))(g)
(%f f(f(f(x))))(g)
(%f f(f(f(x))))(%t a(c(t)))
(%f f(f(f(x))))(%t t*t)
(%f f(f(f(x))))(%t a(b,c[t],d))

3-a
3-a-i
%x loves(Mary,x)

3-a-ii
loves(Mary)

3-b
The semantic of VP (love) is that the lover is Mary and the lovee is John

3-c-i
f = %y A%x woman(x)->loves(x,y)

3-c-ii
f(John) is that every woman loves John
f(x) is that every woman loves x

3-d
f(g) = %x Obviously(g(x))
To build the semantics of “Sue obviously loves Mary", we need to
f(g)(Sue) where g = %y loves(Sue,y)

3-e
f = %x %y (λe act(e, loving), lovee(e, x), lover(e, y))

3-f
f(Mary) = %y (λe act(e, loving), lovee(e, Mary), lover(e, y)) = %y λe act(e, loving), lovee(e, Mary), lover(e, y)
g(f(Mary)) = %y (λe act(e, loving), lovee(e, Mary), lover(e, y), manner(e, passionate))
As a result, we can conclude that g is as follows:
g(h) = %y %e h(y,e), manner(e, passionate)

3-g-i
f (λx loves(Mary, x)) = (∀y woman(y) ⇒ loves(M ary, y))
As a result,
f(g) = (A%y woman(y) -> g(y))

3-g-ii
In English
f (λx loves(Mary, x)) means: every woman is loved by Mary
g = (λx loves(Mary, x)), then g(x) means: x is loved by Mary
f(s) means that every woman has the attributed indicated by s

3-h-i
f(g) = (A%y woman(y) -> g(y))
f = %g A%y woman(y) -> g(y)
f = %t A%y woman(y) -> t(y)
g(woman) = f = %t A%y woman(y) -> t(y)
g = %h %t A%y h(y) -> t(y)

3-h-ii
In english, g(h,t) means that every entity with the attribute indicated by h has the attribute indicated by t

3-i-i
f (λx loves(Mary, x)) = loves(Mary, Papa)
f(g) = g(Papa)
f = %g g(Papa)

3-i-ii
f = %g g(Papa)
f(g) means that Papa is with the attribute indicated by g
f(g1), f(g2), f(g3)..... means that Papa is with the attributes indicated by g1, g2, g3.....
One may want function f because he wants to conveniently describe Papa.

4.
./parseattrs  english.gra  english.sen
./parseattrs  english.gra  english.sen > english.para

Here are the english sentences with wrong parse:
him love -s she .
Papa eat -ed every bonbon with a spoon .
Papa want -ed a pickle to eat Joe .
Papa would have eat -ed his sandwich -s .

1. him love -s she .
This is an ungrammatical sentence while it is not printed that "there is no consistent way to assign attributes"
The attributes are inappropriate because it clear that the subject is a man and the object is a woman. However, we have:
(NP: him ; Attributes: head=him sem=him num=sing case=obj) and (NP: she ; Attributes: num=sing head=she sem=her case=subj)
It would not have helped if the parser had chosen a different parse.

2. Papa eat -ed every bonbon with a spoon .
This is a grammatical sentence while the system didn't find the most plausible semantics.
Given the parse tree, the attributes are appropriate.
However, it would have helped if the parser had chosen a different parse.
In our parse tree, we decompose (VP: eat -ed every bonbon with a spoon) into (V: eat -ed) and (NP: every bonbon with a spoon)
In idea parse tree, we decompose (VP: eat -ed every bonbon with a spoon) into (VP: eat -ed every bonbon) and (PP: with a spoon)

3. Papa want -ed a pickle to eat Joe .
This is a grammatical sentence while the system didn't find the most plausible semantics.
Given the parse tree, the attributes are appropriate.
However, it would have helped if the parser had chosen a different parse.
In our parse tree, we decompose (VP: want -ed a pickle to eat Joe) into (V: want -ed) and (NP: a pickle) and (VP: to eat Joe)
In idea parse tree, we decompose (VP: want -ed a pickle to eat Joe) into (VP: want -ed a pickle) and (PP: to eat Joe)
It is clearly that a pickle can't eat something. "Papa wanted a pickle to eat Joe" is similar with "I want the fork and knife to eat beef steak"

4. Papa would have eat -ed his sandwich -s .
This is a grammatical sentence while the system didn't find the most plausible semantics.
However, it would not have helped if the parser had chosen a different parse.
Given the parse tree, the attributes are almost appropriate. However, there is a small problem.
When we are dealing with the tenses, we are moving the tense attribute of a smaller constituent into the sem attribute of the bigger constituent.
For example, we have a small constituent (VP: been delicious ; Attributes: tense=pastp head=be sem=%subj delicious(subj)) and a bigger constituent (VP: to have been delicious ; Attributes: head=be sem=%subj Perf(delicious(subj)) arg=np tense=inf) in next sentence
We are moving the "tense=pastp" of the small constituent into the "sem=%subj Perf(delicious(subj))" of the bigger constituent. Namely, tense=pastp --> Perf()
However, in this sentence, (VP: would have eat -ed his sandwich -s ; Attributes: sem=%subj would(Perf(eat(the_plural(%x sandwich(x)^possess(x,him)),subj))) head=eat arg=np tense=modal)
We have "tense=modal" and "sem = **** would *****" at the same time, which is inappropriate.



























